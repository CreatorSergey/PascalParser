/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"


namespace PascalLike {



void Parser::Err(const QString& msg) {
    if (errDist >= minErrDist) errors->Error(la->line, la->col, msg);
    errDist = 0;
}


void Parser::SemErr(const wchar_t* msg) {
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		t = la;
		la = scanner->Scan();
       // gen->line = la->line;
       // gen->col = la->col;
       // tab->line = la->line;
       // tab->col = la->col;
		if (la->kind <= maxT) { ++errDist; break; }

		if (dummyToken != t) {
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}

void Parser::Expect(int n) {
	if (la->kind==n) Get(); else { 
        SynErr(n); 
    }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::IdentRW(AST::ident &ident) {
		if (StartOf(1)) {
			Ident(ident);
		} else if (la->kind == _READ) {
			Get();
			ident._ident = "Read"; 
		} else if (la->kind == _WRITE) {
			Get();
			ident._ident = "Write"; 
		} else SynErr(171);
}

void Parser::Ident(AST::ident &ident) {
		switch (la->kind) {
		case _ident: {
			Get();
			break;
		}
		case _DIV: {
			Get();
			break;
		}
		case _IN: {
			Get();
			break;
		}
		case _MOD: {
			Get();
			break;
		}
		case _SHL: {
			Get();
			break;
		}
		case _SHR: {
			Get();
			break;
		}
		default: SynErr(172); break;
		}
		ident._ident = ReadString(t);
		                
}

void Parser::Constant(AST::constant &constant) {
		switch (la->kind) {
		case _intcon: {
			Get();
			constant._constant = ReadInteger(t,0,10);  
			break;
		}
		case _realcon: {
			Get();
			constant._constant = ReadString(t).toDouble(); 
			break;
		}
		case _TRUE: {
			Get();
			constant._constant = true; 
			break;
		}
		case _FALSE: {
			Get();
			constant._constant = false; 
			break;
		}
		case _bincon: {
			Get();
			constant._constant = ReadInteger(t,2,2); 
			break;
		}
		case _octcon: {
			Get();
			constant._constant = ReadInteger(t,2,8); 
			break;
		}
		case _hexcon: {
			Get();
			constant._constant = ReadInteger(t,3,16); 
			break;
		}
		case _string: case _character: {
			QString s; 
			CString(s);
			constant._constant = s; 
			break;
		}
		case 165 /* "[" */: {
			AST::set_construct set_construct(cur()); 
			Get();
			ExprList(set_construct._expr_list);
			Expect(166 /* "]" */);
			constant._constant = set_construct; 
			break;
		}
		default: SynErr(173); break;
		}
}

void Parser::CString(QString& s) {
		if (la->kind == _string) {
			Get();
			s.append( ReadString(t, true) ) ; 
		} else if (la->kind == _character) {
			Get();
			s.append( QChar( (int)ReadInteger(t, 1) ) ) ; 
		} else SynErr(174);
		while (la->kind == _string || la->kind == _character) {
			if (la->kind == _string) {
				Get();
				s.append( ReadString(t, true) ); 
			} else {
				Get();
				s.append( QChar( (int)ReadInteger(t, 1) ) ) ;  
			}
		}
}

void Parser::ExprList(AST::expr_list &expr_list) {
		AST::expr expr(cur());  AST::ident ident(cur()); 
		if (IsBoundSt()) {
			Ident(ident);
			expr_list._idents << ident; 
			if (la->kind == _colon) {
				Get();
			} else if (la->kind == _LET) {
				Get();
			} else SynErr(175);
		}
		Expr(expr);
		expr_list._exprs << expr; 
		while (la->kind == _semicol || la->kind == 169 /* "," */) {
			if (la->kind == 169 /* "," */) {
				Get();
			} else {
				Get();
			}
			if (IsBoundSt()) {
				Ident(ident);
				expr_list._idents << ident; 
				if (la->kind == _colon) {
					Get();
				} else if (la->kind == _LET) {
					Get();
				} else SynErr(176);
			}
			Expr(expr);
			expr_list._exprs << expr; 
		}
}

void Parser::Expr(AST::expr &expr) {
		AST::expr right; AST::binary binary(cur());  
		SimExpr(expr);
		while (StartOf(2)) {
			RelOp(binary._op);
			SimExpr(right);
			binary._left = expr; binary._right = right; expr._expr = binary; 
		}
}

void Parser::SimExpr(AST::expr &expr) {
		AST::expr right; AST::binary binary(cur());  
		Term(expr);
		while (StartOf(3)) {
			AddOp(binary._op);
			Term(right);
			binary._left = expr; binary._right = right; expr._expr = binary; 
		}
}

void Parser::RelOp(BytecodeVM::BinOp &op) {
		switch (la->kind) {
		case _GT: {
			Get();
			op = BytecodeVM::GT; 
			break;
		}
		case _LT: {
			Get();
			op = BytecodeVM::LT; 
			break;
		}
		case _LE: {
			Get();
			op = BytecodeVM::LE; 
			break;
		}
		case _GE: {
			Get();
			op = BytecodeVM::GE; 
			break;
		}
		case _EQ: {
			Get();
			op = BytecodeVM::EQ; 
			break;
		}
		case _NE: {
			Get();
			op = BytecodeVM::NE; 
			break;
		}
		case _C_EQ: {
			Get();
			op = BytecodeVM::EQ; 
			break;
		}
		case _C_NEQ: {
			Get();
			op = BytecodeVM::NE; 
			break;
		}
		default: SynErr(177); break;
		}
}

void Parser::Term(AST::expr &expr) {
		AST::expr right; AST::binary binary(cur()); 
		Term2(expr);
		while (StartOf(4)) {
			MulOp(binary._op);
			Term2(right);
			binary._left = expr; binary._right = right; expr._expr = binary; 
		}
}

void Parser::AddOp(BytecodeVM::BinOp &op) {
		switch (la->kind) {
		case _PLUS: {
			Get();
			op = BytecodeVM::PLUS; 
			break;
		}
		case _MINUS: {
			Get();
			op = BytecodeVM::MINUS; 
			break;
		}
		case _OR: {
			Get();
			op = BytecodeVM::OR; 
			break;
		}
		case _XOR: {
			Get();
			op = BytecodeVM::XOR; 
			break;
		}
		case _C_OR: {
			Get();
			op = BytecodeVM::ORLOG; 
			break;
		}
		case _C_ORBIN: {
			Get();
			op = BytecodeVM::ORBIN; 
			break;
		}
		default: SynErr(178); break;
		}
}

void Parser::Term2(AST::expr &expr) {
		AST::expr right; AST::binary binary(cur()); 
		SimpleExpr(expr);
		while (StartOf(5)) {
			BinaryOp(binary._op);
			SimpleExpr(right);
			binary._left = expr; binary._right = right; expr._expr = binary; 
		}
}

void Parser::MulOp(BytecodeVM::BinOp &op) {
		switch (la->kind) {
		case _MUL: {
			Get();
			op = BytecodeVM::MUL; 
			break;
		}
		case _DIV: {
			Get();
			op = BytecodeVM::DIV; 
			break;
		}
		case _DIVR: {
			Get();
			op = BytecodeVM::DIVR; 
			break;
		}
		case _MOD: {
			Get();
			op = BytecodeVM::MOD; 
			break;
		}
		case _AND: {
			Get();
			op = BytecodeVM::AND; 
			break;
		}
		case _C_MOD: {
			Get();
			op = BytecodeVM::MOD; 
			break;
		}
		case _C_AND: {
			Get();
			op = BytecodeVM::ANDLOG; 
			break;
		}
		case _C_ANDBIN: {
			Get();
			op = BytecodeVM::ANDBIN; 
			break;
		}
		default: SynErr(179); break;
		}
}

void Parser::SimpleExpr(AST::expr &expr) {
		expr = AST::expr(cur()); AST::unary unary(cur());
		if (la->kind == _PLUS) {
			Get();
			PrimaryExprWrap(unary._expr);
			unary._op = BytecodeVM::UPLUS; expr._expr = unary;  
		} else if (la->kind == _MINUS) {
			Get();
			PrimaryExprWrap(unary._expr);
			unary._op = BytecodeVM::UMINUS;expr._expr = unary;  
		} else if (la->kind == _NOT || la->kind == _C_NOT) {
			if (la->kind == _NOT) {
				Get();
			} else {
				Get();
			}
			PrimaryExprWrap(unary._expr);
			unary._op = BytecodeVM::UNOT;expr._expr = unary;  
		} else if (la->kind == 167 /* "~" */) {
			Get();
			PrimaryExprWrap(unary._expr);
			unary._op = BytecodeVM::UINV;expr._expr = unary;  
		} else if (StartOf(6)) {
			PrimaryExprWrap(expr);
		} else SynErr(180);
}

void Parser::BinaryOp(BytecodeVM::BinOp &op) {
		if (la->kind == _SHL) {
			Get();
			op = BytecodeVM::SHL; 
		} else if (la->kind == _SHR) {
			Get();
			op = BytecodeVM::SHR; 
		} else if (la->kind == _C_SHL) {
			Get();
			op = BytecodeVM::SHL; 
		} else if (la->kind == _C_SHR) {
			Get();
			op = BytecodeVM::SHR; 
		} else SynErr(181);
}

void Parser::PrimaryExprWrap(AST::expr &expr) {
		AST::primary primary; 
		PrimaryExpr(primary);
		expr._expr = primary; 
}

void Parser::PrimaryExpr(AST::primary &primary) {
		primary = AST::primary(cur());
		AST::expr_list expr_list;
		AST::constant constant(cur()); AST::ident ident(cur()), field(cur());
		
		if (la->kind == _OPENPAR) {
			Get();
			ExprList(expr_list);
			Expect(_CLOSEPAR);
			primary._expr=expr_list;   
		} else if (StartOf(7)) {
			AST::internalexpr internalexpr(cur()); 
			Internalexpr(internalexpr);
			primary._expr=internalexpr; 
		} else if (StartOf(8)) {
			Constant(constant);
			primary._expr=constant; 
		} else if (StartOf(1)) {
			Ident(ident);
			primary._expr=ident;  
			while (StartOf(9)) {
				AST::primary_accessor primary_accessor(cur()); 
				Primary_accessor(primary_accessor);
				primary._accessors << primary_accessor; 
			}
		} else if (la->kind == 168 /* "@" */) {
			Get();
			PrimaryExpr(primary);
			AST::primary_accessor primary_accessor(cur());
			primary_accessor._primary_accessor =  AST::address_expr();
			primary._accessors << primary_accessor;
			
		} else SynErr(182);
}

void Parser::Internalexpr(AST::internalexpr &internalexpr) {
		switch (la->kind) {
		case _LOW: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tLow;   
			break;
		}
		case _HIGH: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tHigh;   
			break;
		}
		case _INC: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tInc;   
			break;
		}
		case _DEC: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tDec;   
			break;
		}
		case _M_ADD: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tAdd;   
			break;
		}
		case _AND: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tAnd;   
			break;
		}
		case _M_CONCAT: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tConcat;   
			break;
		}
		case _M_EQ: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tEq;   
			break;
		}
		case _M_NE: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tNe;   
			break;
		}
		case _M_GE: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tGe;   
			break;
		}
		case _M_GT: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tGt;   
			break;
		}
		case _M_LE: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tLe;   
			break;
		}
		case _M_LT: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tLt;   
			break;
		}
		case _M_MAX: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tMax;   
			break;
		}
		case _M_MIN: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tMin;   
			break;
		}
		case _M_MUL: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tMul;   
			break;
		}
		case _OR: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tOr;   
			break;
		}
		case _XOR: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tXor;   
			break;
		}
		case _M_MUX: {
			Get();
			Expect(_OPENPAR);
			ExprList(internalexpr._expr_list);
			Expect(_CLOSEPAR);
			internalexpr._type = AST::internalexpr::tMux;   
			break;
		}
		default: SynErr(183); break;
		}
}

void Parser::Primary_accessor(AST::primary_accessor &primary_accessor) {
		AST::call_expr call_expr(cur()); AST::deref_expr deref_expr(cur()); AST::idx_expr idx_expr(cur()); AST::access_expr access_expr(cur()); 
		if (la->kind == 165 /* "[" */) {
			Get();
			ExprList(idx_expr._indexes);
			Expect(166 /* "]" */);
			primary_accessor._primary_accessor = idx_expr; 
		} else if (la->kind == _dot) {
			Get();
			IdentRW(access_expr._field);
			primary_accessor._primary_accessor = access_expr; 
		} else if (la->kind == _CIRCUM) {
			Get();
			primary_accessor._primary_accessor = deref_expr; 
		} else if (la->kind == _OPENPAR) {
			Get();
			if (StartOf(10)) {
				ExprList(call_expr._args);
			}
			Expect(_CLOSEPAR);
			primary_accessor._primary_accessor = call_expr; 
		} else SynErr(184);
}

void Parser::Annotation(AST::annotation &annotation) {
		Expect(_OPEN_ANNO);
		ExprList(annotation._expr_list);
		Expect(_CLOSE_ANNO);
}

void Parser::Sequence(AST::sequence &sequence) {
		AST::statement statement(cur());  
		Statement(statement);
		if (statement._statement.which()) // may be empty Statement.
		   sequence._statements << statement;
		
		while (la->kind == _semicol) {
			Get();
			Statement(statement);
			if (statement._statement.which()) // may be empty Statement.
			  sequence._statements << statement;  
		}
}

void Parser::Statement(AST::statement &statement) {
		statement = AST::statement();    AST::internalfst internalfst(cur());  
		if (StartOf(11)) {
			if (IsLabelSt()) {
				AST::labelst labelst(cur());  
				Labelst(labelst);
				statement._statement = labelst; 
			} else if (IsAssignment()) {
				AST::assignmentst assignmentst(cur()); 
				Assignmentst(assignmentst);
				statement._statement = assignmentst; 
			} else if (StartOf(6)) {
				AST::procst procst(cur());  
				Procst(procst);
				statement._statement = procst; 
			} else if (la->kind == _BEGIN) {
				AST::compoundst compoundst(cur());  
				Compoundst(compoundst);
				statement._statement = compoundst; 
			} else if (la->kind == _GOTO) {
				AST::gotost gotost(cur());  
				Gotost(gotost);
				statement._statement = gotost; 
			} else if (la->kind == _CASE) {
				AST::switchst switchst(cur());  
				Switchst(switchst);
				statement._statement = switchst; 
			} else if (la->kind == _IF_) {
				AST::ifst ifst(cur());  
				Ifst(ifst);
				statement._statement = ifst; 
			} else if (la->kind == _FOR) {
				AST::forst forst(cur());  
				Forst(forst);
				statement._statement = forst; 
			} else if (la->kind == _WHILE) {
				AST::whilest whilest(cur());  
				Whilest(whilest);
				statement._statement = whilest; 
			} else if (la->kind == _REPEAT) {
				AST::repeatst repeatst(cur());  
				Repeatst(repeatst);
				statement._statement = repeatst; 
			} else if (la->kind == _WITH) {
				AST::withst withst(cur());  
				Withst(withst);
				statement._statement = withst; 
			} else if (la->kind == _TRY) {
				AST::tryst tryst(cur());  
				Tryst(tryst);
				statement._statement = tryst; 
			} else if (la->kind == _RAISE_) {
				AST::raisest raisest(cur());  
				Raisest(raisest);
				statement._statement = raisest; 
			} else if (la->kind == _INHERITED) {
				AST::inheritedst inheritedst(cur());  
				Inheritedst(inheritedst);
				statement._statement = inheritedst; 
			} else if (la->kind == _READ || la->kind == _READLN) {
				AST::readst readst(cur());  
				Readst(readst);
				statement._statement = readst; 
			} else if (la->kind == _WRITE || la->kind == _WRITELN) {
				AST::writest writest(cur());  
				Writest(writest);
				statement._statement = writest; 
			} else if (la->kind == _STR) {
				AST::strst strst(cur());  
				Strst(strst);
				statement._statement = strst; 
			} else if (la->kind == _ON) {
				AST::onst onst(cur());  
				Onst(onst);
				statement._statement = onst; 
			} else {
				AST::internalfst internalfst(cur());  
				Internalfst(internalfst);
				statement._statement = internalfst; 
			}
		}
}

void Parser::Labelst(AST::labelst &labelst) {
		Ident(labelst._ident);
		Expect(_colon);
}

void Parser::Assignmentst(AST::assignmentst &assignmentst) {
		Expr(assignmentst._left);
		Expect(_LET);
		Expr(assignmentst._right);
}

void Parser::Procst(AST::procst &procst) {
		PrimaryExpr(procst._primary);
}

void Parser::Compoundst(AST::compoundst &compoundst) {
		Expect(_BEGIN);
		Sequence(compoundst._sequence);
		Expect(_END_);
}

void Parser::Gotost(AST::gotost &gotost) {
		Expect(_GOTO);
		Expect(_intcon);
		int n; swscanf(t->val, L"%d", &n); gotost._iconst = n; 
}

void Parser::Switchst(AST::switchst &switchst) {
		Expect(_CASE);
		Expr(switchst._case);
		Expect(_OF);
		Case_list(switchst._case_list);
		if (la->kind == _ELSE || la->kind == _OTHERWISE) {
			if (la->kind == _OTHERWISE) {
				Get();
			} else {
				Get();
			}
			Sequence(switchst._else);
		}
		if (la->kind == _END_) {
			Get();
		} else if (la->kind == _END_CASE) {
			Get();
		} else SynErr(185);
}

void Parser::Ifst(AST::ifst &ifst) {
		AST::compoundst cif(cur()), celse(cur()); 
		if (StSemantic()) {
			Expect(_IF_);
			Expr(ifst._expr);
			Expect(_THEN);
			Sequence(cif._sequence);
			ifst._if._statement = cif;  
			if (la->kind == _ELSE) {
				Get();
				Sequence(celse._sequence);
				ifst._else._statement = celse;  
			}
			Expect(_END_IF);
		} else if (la->kind == _IF_) {
			Get();
			Expr(ifst._expr);
			Expect(_THEN);
			Statement(ifst._if);
			if (la->kind == _ELSE) {
				Get();
				Statement(ifst._else);
			}
		} else SynErr(186);
}

void Parser::Forst(AST::forst &forst) {
		forst._downto = false;  AST::compoundst body(cur()); 
		Expect(_FOR);
		Ident(forst._ident);
		Expect(_LET);
		Expr(forst._fromExpr);
		if (la->kind == _TO_) {
			Get();
		} else if (la->kind == _DOWNTO) {
			Get();
			forst._downto = true; 
		} else SynErr(187);
		Expr(forst._toExpr);
		Expect(_DO);
		if (StSemantic()) {
			Sequence(body._sequence);
			forst._statement._statement = body;  
			Expect(_END_FOR);
		} else if (StartOf(12)) {
			Statement(forst._statement);
		} else SynErr(188);
}

void Parser::Whilest(AST::whilest &whilest) {
		AST::compoundst body(cur()); 
		Expect(_WHILE);
		Expr(whilest._expr);
		Expect(_DO);
		if (StSemantic()) {
			Sequence(body._sequence);
			whilest._statement._statement = body;  
			Expect(_END_WHILE);
		} else if (StartOf(12)) {
			Statement(whilest._statement);
		} else SynErr(189);
}

void Parser::Repeatst(AST::repeatst &repeatst) {
		Expect(_REPEAT);
		Sequence(repeatst._sequence);
		Expect(_UNTIL);
		Expr(repeatst._expr);
		if (la->kind == _END_REPEAT) {
			Get();
		}
}

void Parser::Withst(AST::withst &withst) {
		Expect(_WITH);
		PrimaryExpr(withst._expr);
		Expect(_DO);
		Statement(withst._statement);
}

void Parser::Tryst(AST::tryst &tryst) {
		tryst._flags = 0; 
		Expect(_TRY);
		Sequence(tryst._try_);
		if (la->kind == _EXCEPT) {
			Get();
			Sequence(tryst._except_);
			tryst._flags |= AST::tryst::HasExcept; 
		}
		if (la->kind == _FINALLY) {
			Get();
			Sequence(tryst._finally_);
			tryst._flags |= AST::tryst::HasFinally; 
		}
		Expect(_END_);
}

void Parser::Raisest(AST::raisest &raisest) {
		Expect(_RAISE_);
		Expr(raisest._expr);
}

void Parser::Inheritedst(AST::inheritedst &inheritedst) {
		Expect(_INHERITED);
		Ident(inheritedst._ident);
}

void Parser::Readst(AST::readst &readst) {
		readst._isLn =false; 
		if (la->kind == _READ) {
			Get();
		} else if (la->kind == _READLN) {
			Get();
			readst._isLn =true; 
		} else SynErr(190);
		Expect(_OPENPAR);
		ExprList(readst._expr_list);
		Expect(_CLOSEPAR);
}

void Parser::Writest(AST::writest &writest) {
		writest._isLn =false; 
		if (la->kind == _WRITE) {
			Get();
		} else if (la->kind == _WRITELN) {
			Get();
			writest._isLn =true; 
		} else SynErr(191);
		Expect(_OPENPAR);
		Write_list(writest._write_list);
		Expect(_CLOSEPAR);
}

void Parser::Strst(AST::strst &strst) {
		Expect(_STR);
		Expect(_OPENPAR);
		Write_list(strst._write_list);
		Expect(_CLOSEPAR);
}

void Parser::Onst(AST::onst &onst) {
		Expect(_ON);
		Ident(onst._ident);
		Expect(_colon);
		Type(onst._type.get());
		Expect(_DO);
		Statement(onst._statement);
}

void Parser::Internalfst(AST::internalfst &internalfst) {
		if (la->kind == _BREAK) {
			Get();
			if (la->kind == _OPENPAR) {
				Get();
				Expect(_CLOSEPAR);
			}
			internalfst._type = AST::internalfst::tBreak;  
		} else if (la->kind == _CONTINUE) {
			Get();
			if (la->kind == _OPENPAR) {
				Get();
				Expect(_CLOSEPAR);
			}
			internalfst._type = AST::internalfst::tContinue;   
		} else if (la->kind == _EXIT) {
			Get();
			if (la->kind == _OPENPAR) {
				Get();
				Expect(_CLOSEPAR);
			}
			internalfst._type = AST::internalfst::tExit;   
		} else if (la->kind == _RETURN) {
			Get();
			if (la->kind == _OPENPAR) {
				Get();
				Expect(_CLOSEPAR);
			}
			internalfst._type = AST::internalfst::tExit;   
		} else SynErr(192);
}

void Parser::Case_list(AST::case_list &case_list) {
		AST::case_list_elem case_list_elem(cur()); 
		Case_list_elem(case_list_elem);
		case_list << case_list_elem; 
		while (la->kind == _semicol) {
			Get();
			if (StartOf(10)) {
				Case_list_elem(case_list_elem);
				case_list << case_list_elem; 
			}
		}
}

void Parser::Case_list_elem(AST::case_list_elem &case_list_elem) {
		case_list_elem = AST::case_list_elem();  
		ExprList(case_list_elem._expr_list);
		Expect(_colon);
		Statement(case_list_elem._statement);
}

void Parser::Write_list(AST::write_list &write_list) {
		AST::write_param write_param(cur()); 
		Write_param(write_param);
		write_list._write_params << write_param; 
		while (la->kind == 169 /* "," */) {
			Get();
			Write_param(write_param);
			write_list._write_params << write_param; 
		}
}

void Parser::Type(AST::type &type) {
		type = AST::type(cur());  
		switch (la->kind) {
		case _ident: case _DIV: case _IN: case _MOD: case _SHL: case _SHR: {
			AST::simple_type simple_type(cur()); 
			Simple_type(simple_type);
			type._type = simple_type; 
			break;
		}
		case _ARRAY: {
			AST::array_type array_type(cur()); 
			Array_type(array_type);
			type._type = array_type; 
			break;
		}
		case _RECORD: {
			AST::class_type class_type(cur()); 
			Record_type(class_type);
			type._type = class_type; 
			break;
		}
		case _SET: {
			AST::set_type set_type(cur()); 
			Set_type(set_type);
			type._type = set_type; 
			break;
		}
		case _FILE: {
			AST::file_type file_type(cur()); 
			File_type(file_type);
			type._type = file_type; 
			break;
		}
		case _CIRCUM: {
			AST::pointer_type pointer_type(cur()); 
			Pointer_type(pointer_type);
			type._type = pointer_type; 
			break;
		}
		case 165 /* "[" */: {
			AST::subrange_type subrange_type(cur()); 
			Subrange_type(subrange_type);
			type._type = subrange_type; 
			break;
		}
		case _OPENPAR: {
			AST::enum_type enum_type(cur()); 
			Enum_type(enum_type);
			type._type = enum_type; 
			break;
		}
		case _FUNCTION: case _PROCEDURE: {
			AST::function_type function_type(cur()); 
			Function_type(function_type);
			type._type = function_type; 
			break;
		}
		case _CLASS: {
			AST::class_type class_type(cur()); 
			Class_type(class_type);
			type._type = class_type; 
			break;
		}
		default: SynErr(193); break;
		}
}

void Parser::Write_param(AST::write_param &write_param) {
		AST::constant constant(cur()); 
		Expr(write_param._expr);
		while (la->kind == _colon) {
			Get();
			Constant(constant);
			write_param._constants << constant; 
		}
}

void Parser::Simple_type(AST::simple_type &simple_type) {
		Ident(simple_type._ident);
}

void Parser::Array_type(AST::array_type &array_type) {
		AST::array_range array_range(cur()); 
		Expect(_ARRAY);
		Expect(165 /* "[" */);
		Array_range(array_range);
		array_type._array_ranges << array_range;  
		while (la->kind == 169 /* "," */) {
			Get();
			Array_range(array_range);
			array_type._array_ranges << array_range;  
		}
		Expect(166 /* "]" */);
		Expect(_OF);
		Type(array_type._type);
}

void Parser::Record_type(AST::class_type &class_type) {
		Expect(_RECORD);
		; class_type._sections.clear();
		AST::class_section section;
		section._flags = AST::class_section::IsPublic;
		class_type._flags |= AST::class_type::IsRecord;
		
		Var_decls(section._var_decls);
		; class_type._sections <<section;  
		Expect(_END_);
}

void Parser::Set_type(AST::set_type &set_type) {
		Expect(_SET);
		Expect(_OF);
		Type(set_type._type);
}

void Parser::File_type(AST::file_type &file_type) {
		Expect(_FILE);
		Expect(_OF);
		Type(file_type._type);
}

void Parser::Pointer_type(AST::pointer_type &pointer_type) {
		Expect(_CIRCUM);
		Type(pointer_type._type);
}

void Parser::Subrange_type(AST::subrange_type &subrange_type) {
		Expect(165 /* "[" */);
		Expr(subrange_type._boundLow);
		Expect(_dotdot);
		Expr(subrange_type._boundHigh);
		Expect(166 /* "]" */);
}

void Parser::Enum_type(AST::enum_type &enum_type) {
		Expect(_OPENPAR);
		ExprList(enum_type._expr_list);
		Expect(_CLOSEPAR);
}

void Parser::Function_type(AST::function_type &function_type) {
		function_type._isProc = true; 
		if (la->kind == _PROCEDURE) {
			Get();
		} else if (la->kind == _FUNCTION) {
			Get();
			function_type._isProc = false; 
		} else SynErr(194);
}

void Parser::Class_type(AST::class_type &class_type) {
		class_type._flags = 0; 
		Expect(_CLASS);
		if (la->kind == _OPENPAR) {
			Get();
			Ident(class_type._parent);
			Expect(_CLOSEPAR);
		}
		AST::class_section class_section(cur()); 
		Class_section(class_section);
		class_type._sections << class_section; 
		Class_sections(class_type._sections);
		Expect(_END_);
}

void Parser::Array_range(AST::array_range &array_range) {
		array_range._hasLow = false; AST::expr boundHigh(cur()); 
		Expr(array_range._boundHigh);
		if (la->kind == _dotdot) {
			Get();
			Expr(boundHigh);
			array_range._boundLow = array_range._boundHigh;
			array_range._boundHigh = boundHigh;
			array_range._hasLow = true;
			
		}
}

void Parser::Var_decls(AST::var_decls &var_decls) {
		AST::var_decl var_decl(cur()); 
		Var_decl(var_decl);
		Expect(_semicol);
		var_decls << var_decl;  
		while (StartOf(1)) {
			AST::var_decl var_decl(cur()); 
			Var_decl(var_decl);
			Expect(_semicol);
			var_decls << var_decl;  
		}
}

void Parser::Class_section(AST::class_section &class_section) {
		AST::proc_def proc_def(cur()); 
		if (StartOf(1)) {
			Var_decls(class_section._var_decls);
		}
		while (StartOf(13)) {
			Proc_def_forward(proc_def);
			class_section._proc_fwd_decls << proc_def;  
		}
}

void Parser::Class_sections(AST::class_sections &class_sections) {
		while (la->kind == _PRIVATE || la->kind == _PROTECTED || la->kind == _PUBLIC) {
			AST::class_section class_section(cur()); 
			if (la->kind == _PUBLIC) {
				Get();
				class_section._flags = AST::class_section::IsPublic; 
			} else if (la->kind == _PROTECTED) {
				Get();
				class_section._flags = AST::class_section::IsProtected; 
			} else {
				Get();
				class_section._flags = AST::class_section::IsPrivate; 
			}
			Class_section(class_section);
			class_sections << class_section; 
		}
}

void Parser::Proc_def_forward(AST::proc_def &proc_def) {
		proc_def._isForward = true; 
		Proc_decl(proc_def._proc_decl);
		Expect(_semicol);
		Proc_def_params(proc_def);
}

void Parser::Decl_part(AST::decl_part& decl_part) {
		decl_part = AST::decl_part();  
		if (StartOf(14)) {
			Decl_part_common(decl_part);
		} else if (StartOf(13)) {
			AST::proc_def proc_def(cur()); 
			Proc_def(proc_def);
			decl_part._decl_part = proc_def; 
		} else SynErr(195);
}

void Parser::Decl_part_common(AST::decl_part& decl_part) {
		decl_part = AST::decl_part();  
		if (la->kind == _LABEL) {
			AST::label_decl_part label_decl_part(cur()); 
			Label_decl_part(label_decl_part);
			decl_part._decl_part = label_decl_part; 
		} else if (la->kind == _CONST) {
			AST::const_def_part const_def_part(cur()); 
			Const_def_part(const_def_part);
			decl_part._decl_part = const_def_part; 
		} else if (la->kind == _TYPE) {
			AST::type_def_part type_def_part(cur()); 
			Type_def_part(type_def_part);
			decl_part._decl_part = type_def_part; 
		} else if (la->kind == _VAR) {
			AST::var_decl_part var_decl_part(cur()); 
			Var_decl_part(var_decl_part);
			decl_part._decl_part = var_decl_part; 
		} else if (la->kind == _USES) {
			AST::uses_part uses_part(cur()); 
			Uses_part(uses_part);
			decl_part._decl_part = uses_part; 
		} else SynErr(196);
}

void Parser::Proc_def(AST::proc_def &proc_def) {
		proc_def._isForward = true; 
		Proc_decl(proc_def._proc_decl);
		Expect(_semicol);
		if (la->kind == _FORWARD) {
			Get();
			Expect(_semicol);
		} else if (StartOf(15)) {
			Block(proc_def._block);
			proc_def._isForward = false; 
			Expect(_semicol);
		} else SynErr(197);
		Proc_def_params(proc_def);
}

void Parser::Decl_part_forward(AST::decl_part& decl_part) {
		decl_part = AST::decl_part();  
		if (StartOf(14)) {
			Decl_part_common(decl_part);
		} else if (StartOf(13)) {
			AST::proc_def proc_def(cur()); 
			Proc_def_forward(proc_def);
			decl_part._decl_part = proc_def; 
		} else SynErr(198);
}

void Parser::Label_decl_part(AST::label_decl_part& label_decl_part) {
		AST::ident ident(cur()); 
		Expect(_LABEL);
		Ident(ident);
		label_decl_part._idents << ident; 
		while (la->kind == 169 /* "," */) {
			Get();
			Ident(ident);
			label_decl_part._idents << ident; 
		}
		Expect(_semicol);
}

void Parser::Const_def_part(AST::const_def_part &const_def_part) {
		AST::const_def  const_def(cur());
		Expect(_CONST);
		Const_def(const_def);
		const_def_part._const_defs << const_def; 
		while (StartOf(1)) {
			Const_def(const_def);
			const_def_part._const_defs << const_def; 
		}
}

void Parser::Type_def_part(AST::type_def_part &type_def_part) {
		AST::type_def  type_def(cur());
		Expect(_TYPE);
		Type_def(type_def);
		type_def_part._type_defs << type_def; 
		while (StartOf(1)) {
			Type_def(type_def);
			type_def_part._type_defs << type_def; 
		}
}

void Parser::Var_decl_part(AST::var_decl_part &var_decl_part) {
		Expect(_VAR);
		Var_decls(var_decl_part._var_decls );
}

void Parser::Uses_part(AST::uses_part& uses_part) {
		AST::ident ident(cur()); 
		Expect(_USES);
		Ident(ident);
		uses_part._idents << ident; 
		while (la->kind == 169 /* "," */) {
			Get();
			Ident(ident);
			uses_part._idents << ident; 
		}
		Expect(_semicol);
}

void Parser::Const_def(AST::const_def &const_def) {
		Ident(const_def._ident);
		if (la->kind == _colon) {
			Get();
			Type(const_def._type);
		}
		Expect(_EQ);
		Expr(const_def._initializer);
		Expect(_semicol);
}

void Parser::Type_def(AST::type_def &type_def) {
		Ident(type_def._ident);
		Expect(_EQ);
		Type(type_def._type);
		Expect(_semicol);
}

void Parser::Decl_part_list(AST::decl_part_list& decl_part_list) {
		AST::decl_part decl_part(cur()); 
		Decl_part(decl_part);
		decl_part_list._parts << decl_part;  
		while (StartOf(16)) {
			Decl_part(decl_part);
			decl_part_list._parts << decl_part;  
		}
}

void Parser::Decl_part_list_forward(AST::decl_part_list& decl_part_list) {
		AST::decl_part decl_part(cur()); 
		Decl_part_forward(decl_part);
		decl_part_list._parts << decl_part;  
		while (StartOf(16)) {
			Decl_part_forward(decl_part);
			decl_part_list._parts << decl_part;  
		}
}

void Parser::Var_decl(AST::var_decl& var_decl) {
		var_decl._idents.clear();var_decl._initializer = AST::expr(); 
		AST::ident ident(cur()); 
		Ident(ident);
		var_decl._idents << ident; 
		while (la->kind == 169 /* "," */) {
			Get();
			AST::ident ident(cur()); 
			Ident(ident);
			var_decl._idents << ident; 
		}
		Expect(_colon);
		Type(var_decl._type);
		if (la->kind == _LET || la->kind == _EQ) {
			if (la->kind == _EQ) {
				Get();
			} else {
				Get();
			}
			Expr(var_decl._initializer);
		}
		if (la->kind == _OPEN_ANNO) {
			Annotation(var_decl._annotation);
		}
}

void Parser::Proc_decl(AST::proc_decl &proc_decl) {
		proc_decl._flags = 0; 
		if (la->kind == _PROCEDURE) {
			Get();
			proc_decl._flags  |= AST::proc_decl::IsProcedure; 
		} else if (la->kind == _FUNCTION) {
			Get();
			proc_decl._flags  |= AST::proc_decl::IsFunction; 
		} else if (la->kind == _CONSTRUCTOR) {
			Get();
			proc_decl._flags  |= AST::proc_decl::IsConstructor; 
		} else if (la->kind == _DESTRUCTOR) {
			Get();
			proc_decl._flags  |= AST::proc_decl::IsDestructor; 
		} else SynErr(199);
		Ident(proc_decl._ident);
		AST::ident tmpIdent(cur()), tmpIdent2(cur()); 
		if (la->kind == _dot) {
			Get();
			Ident(tmpIdent);
			proc_decl._class =proc_decl._ident; proc_decl._ident =tmpIdent;   
		}
		if (la->kind == _OPENPAR) {
			Formal_params(proc_decl._formal_params);
		}
		if (la->kind == _colon) {
			Get();
			Type(proc_decl._type);
		}
}

void Parser::Formal_params(AST::formal_params &formal_params) {
		formal_params.clear(); AST::formal_param formal_param(cur()); 
		Expect(_OPENPAR);
		if (la->kind == _CLOSEPAR) {
			Get();
		} else if (StartOf(17)) {
			Formal_param(formal_param);
			formal_params << formal_param; 
			while (la->kind == _semicol) {
				Get();
				Formal_param(formal_param);
				formal_params << formal_param; 
			}
			Expect(_CLOSEPAR);
		} else SynErr(200);
}

void Parser::Block(AST::block& block) {
		
		if (StartOf(16)) {
			Decl_part_list(block._decl_part_list);
		}
		Compoundst(block._compoundst);
}

void Parser::Proc_def_params(AST::proc_def &proc_def) {
		if (la->kind == _OVERRIDE) {
			Get();
			Expect(_semicol);
			proc_def._proc_decl._flags |= AST::proc_decl::IsOverride;  
		}
		if (la->kind == _OVERLOAD) {
			Get();
			Expect(_semicol);
			proc_def._proc_decl._flags |= AST::proc_decl::IsOverload;  
		}
}

void Parser::Formal_param(AST::formal_param &formal_param) {
		formal_param._flags = 0; 
		if (StartOf(18)) {
			if (la->kind == _VAR) {
				Get();
				formal_param._flags |= AST::formal_param::IsVar; 
			}
			if (la->kind == _CONST) {
				Get();
				formal_param._flags |= AST::formal_param::IsConst; 
			}
			AST::var_decl var_decl(cur());  
			Var_decl(var_decl);
			formal_param._formal_param = var_decl; 
		} else if (StartOf(13)) {
			AST::proc_decl proc_decl(cur()); 
			Proc_decl(proc_decl);
			formal_param._formal_param = proc_decl; 
		} else SynErr(201);
}

void Parser::Pascal() {
		_pascal = AST::pascalSource();AST::stProgram stProgram(cur()); 
		if (StSemantic()) {
			StProgram(stProgram);
			_pascal._pascal = stProgram; 
		} else if (la->kind == _PROGRAM) {
			AST::program program(cur()); 
			Program(program);
			Expect(_dot);
			_pascal._pascal = program; 
		} else if (la->kind == _UNIT) {
			AST::unit unit(cur()); 
			Unit(unit);
			Expect(_dot);
			_pascal._pascal = unit; 
		} else SynErr(202);
}

void Parser::StProgram(AST::stProgram& program) {
		program._hasProgram = false; 
		if (la->kind == _FUNCTION || la->kind == _TYPE || la->kind == _FUNCTION_BLOCK) {
			StDecl_part_list(program._decl_part_list);
		}
		if (la->kind == _PROGRAM) {
			Get();
			program._hasProgram = true; 
			Ident(program._program._proc_decl._ident);
			FBlock(program._program);
			Expect(_END_PROGRAM);
		}
}

void Parser::Program(AST::program& program) {
		Expect(_PROGRAM);
		Ident(program._ident);
		Expect(_semicol);
		Block(program._block);
}

void Parser::Unit(AST::unit& unit) {
		unit._flags =0; 
		Expect(_UNIT);
		Ident(unit._ident);
		Expect(_semicol);
		if (la->kind == _INTERFACE) {
			Get();
			Decl_part_list_forward(unit._interface);
			unit._flags |= AST::unit::HasInterface;  
		}
		if (la->kind == _IMPLEMENTATION) {
			Get();
			if (StartOf(16)) {
				Decl_part_list(unit._implementation);
				unit._flags |= AST::unit::HasImplementation;  
			}
		}
		if (la->kind == _BEGIN) {
			Get();
			Sequence(unit._block);
			unit._flags |= AST::unit::HasBlock;  
		}
		if (la->kind == _INITIALIZATION) {
			Get();
			Sequence(unit._initialization);
			unit._flags |= AST::unit::HasInit;  
		}
		if (la->kind == _FINALIZATION) {
			Get();
			Sequence(unit._finalization);
			unit._flags |= AST::unit::HasFin;  
		}
		Expect(_END_);
}

void Parser::StDecl_part_list(AST::decl_part_list& decl_part_list) {
		AST::decl_part decl_part(cur()); 
		StDecl_part(decl_part);
		decl_part_list._parts << decl_part;  
		while (la->kind == _FUNCTION || la->kind == _TYPE || la->kind == _FUNCTION_BLOCK) {
			StDecl_part(decl_part);
			decl_part_list._parts << decl_part;  
		}
}

void Parser::FBlock(AST::proc_def& proc_def) {
		proc_def._isForward = false; 
		while (StartOf(19)) {
			if (la->kind == _VAR || la->kind == _VAR_EXTERNAL || la->kind == _VAR_CONST) {
				StVarDecl(proc_def._block._decl_part_list._parts);
			} else {
				StParamDecl(proc_def._proc_decl._formal_params);
			}
		}
		Sequence(proc_def._block._compoundst._sequence);
}

void Parser::StVarDecl(AST::decl_parts& decl_parts) {
		AST::decl_part decl_part(cur());
		bool IsStatic = false, IsConst = false, IsExternal = false;
		AST::var_decl_part var_decl_part(cur());
		
		if (la->kind == _VAR) {
			Get();
			if (la->kind == _RETAIN) {
				Get();
				IsStatic = true; 
			}
			if (la->kind == _CONST) {
				Get();
				IsConst = true; 
			}
			if (la->kind == _CONSTANT) {
				Get();
				IsConst = true; 
			}
		} else if (la->kind == _VAR_EXTERNAL) {
			Get();
			IsExternal = true; 
		} else if (la->kind == _VAR_CONST) {
			Get();
			IsConst = true; 
		} else SynErr(203);
		Var_decls(var_decl_part._var_decls);
		for (int i=0; i < var_decl_part._var_decls.size(); i++) {
		  if (IsStatic)    var_decl_part._var_decls[i]._flags |= AST::var_decl::IsStatic;
		  if (IsConst)     var_decl_part._var_decls[i]._flags |= AST::var_decl::IsConst;
		  if (IsExternal)  var_decl_part._var_decls[i]._flags |= AST::var_decl::IsExternal;
		}
		
		Expect(_END_VAR);
		decl_part._decl_part = var_decl_part;
		decl_parts << decl_part;    
}

void Parser::StParamDecl(AST::formal_params& formal_params) {
		AST::formal_param formal_param(cur());
		AST::var_decl var_decl(cur());
		// int flags = 0;
		
		if (la->kind == _VAR_INPUT) {
			Get();
			var_decl._flags |= AST::var_decl::IsInput; 
		} else if (la->kind == _VAR_OUTPUT) {
			Get();
			formal_param._flags |= AST::formal_param::IsVar; var_decl._flags |= AST::var_decl::IsOutput; 
		} else if (la->kind == _VAR_IN_OUT) {
			Get();
			formal_param._flags |= AST::formal_param::IsVar; var_decl._flags |= AST::var_decl::IsInput | AST::var_decl::IsOutput; 
		} else SynErr(204);
		if (la->kind == _RETAIN) {
			Get();
			var_decl._flags |= AST::var_decl::IsStatic; 
		}
		Var_decl(var_decl);
		Expect(_semicol);
		formal_param._formal_param = var_decl;
		formal_params << formal_param;    
		while (StartOf(1)) {
			Var_decl(var_decl);
			Expect(_semicol);
			formal_param._formal_param = var_decl;
			formal_params << formal_param;    
		}
		Expect(_END_VAR);
}

void Parser::StType(AST::type &type) {
		type = AST::type(cur());  
		if (StartOf(1)) {
			AST::simple_type simple_type(cur()); 
			Simple_type(simple_type);
			type._type = simple_type; 
		} else if (la->kind == _ARRAY) {
			AST::array_type array_type(cur()); 
			Array_type(array_type);
			type._type = array_type; 
		} else if (la->kind == _RECORD) {
			AST::class_type class_type(cur()); 
			StRecord_type(class_type);
			type._type = class_type; 
		} else if (la->kind == _CLASS) {
			AST::class_type class_type(cur()); 
			StClass_type(class_type);
			type._type = class_type; 
		} else SynErr(205);
}

void Parser::StRecord_type(AST::class_type &class_type) {
		Expect(_RECORD);
		; class_type._sections.clear();
		AST::class_section section;
		section._flags = AST::class_section::IsPublic;
		class_type._flags |= AST::class_type::IsRecord;
		
		Var_decls(section._var_decls);
		; class_type._sections <<section;  
		Expect(_END_RECORD);
}

void Parser::StClass_type(AST::class_type &class_type) {
		class_type._flags = 0; 
		Expect(_CLASS);
		if (la->kind == _OPEN_ANNO) {
			Annotation(class_type._annotation);
		}
		AST::class_section class_section(cur()); 
		StClass_section(class_section);
		class_type._sections << class_section; 
		StClass_sections(class_type._sections);
		Expect(_END_CLASS);
}

void Parser::StClass_section(AST::class_section &class_section) {
		if (StartOf(1)) {
			Var_decls(class_section._var_decls);
		}
		while (la->kind == _FUNCTION || la->kind == _FUNCTION_BLOCK) {
			AST::proc_def proc_def(cur()); 
			StProc_def(proc_def);
			;class_section._proc_fwd_decls << proc_def;  
		}
}

void Parser::StClass_sections(AST::class_sections &class_sections) {
		while (la->kind == _PRIVATE || la->kind == _PROTECTED || la->kind == _PUBLIC) {
			AST::class_section class_section(cur()); 
			if (la->kind == _PUBLIC) {
				Get();
				class_section._flags = AST::class_section::IsPublic; 
			} else if (la->kind == _PROTECTED) {
				Get();
				class_section._flags = AST::class_section::IsProtected; 
			} else {
				Get();
				class_section._flags = AST::class_section::IsPrivate; 
			}
			StClass_section(class_section);
			class_sections << class_section; 
		}
}

void Parser::StProc_def(AST::proc_def& proc_def) {
		proc_def._isForward=false; 
		if (la->kind == _FUNCTION_BLOCK) {
			Get();
			Ident(proc_def._proc_decl._ident);
			FBlock(proc_def);
			Expect(_END_FUNCTION_BLOCK);
			proc_def._proc_decl._flags |= AST::proc_decl::IsProcedure;
		} else if (la->kind == _FUNCTION) {
			Get();
			Ident(proc_def._proc_decl._ident);
			Expect(_colon);
			Type(proc_def._proc_decl._type);
			FBlock(proc_def);
			Expect(_END_FUNCTION);
			;proc_def._proc_decl._flags |= AST::proc_decl::IsFunction; 
		} else SynErr(206);
}

void Parser::StDecl_part(AST::decl_part& decl_part) {
		decl_part = AST::decl_part();  
		if (la->kind == _TYPE) {
			AST::type_def_part type_def_part(cur()); 
			StType_def_part(type_def_part);
			decl_part._decl_part = type_def_part; 
		} else if (la->kind == _FUNCTION || la->kind == _FUNCTION_BLOCK) {
			AST::proc_def proc_def(cur()); 
			StProc_def(proc_def);
			decl_part._decl_part = proc_def; 
		} else SynErr(207);
}

void Parser::StType_def_part(AST::type_def_part &type_def_part) {
		AST::type_def  type_def(cur());
		Expect(_TYPE);
		Ident(type_def._ident);
		Expect(_colon);
		StType(type_def._type);
		type_def_part._type_defs << type_def; 
		Expect(_END_TYPE);
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	t = NULL;
	la = dummyToken;
	Get();
	Pascal();
	Expect(0);
}

Parser::Parser(Scanner *scanner,AST::CodeMessages *errors) {
	maxT = 170;

	ParserInitCaller<Parser>::CallInit(this);
	dummyToken = new Token();
        dummyToken->val = NULL;
        dummyToken->valSize = 0;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
    this->errors = errors;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[20][172] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, T,x,x,T, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,T,T, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, T,x,x,T, T,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,x,x, x,x,T,x, T,T,T,x, x,x,x,T, T,x,T,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,T,x, T,T,T,x, T,x,x,x, T,x,x,T, T,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, T,x,T,T, x,T,T,x, T,x,x,T, T,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,x,x,x},
		{x,T,T,T, T,T,T,T, T,T,x,x, x,x,T,x, T,T,T,x, x,x,x,T, T,x,T,x, x,T,T,T, x,T,T,x, x,T,T,T, x,x,T,x, T,T,T,x, T,x,x,T, T,x,x,T, T,T,x,x, T,T,x,T, x,x,x,x, x,x,x,x, T,x,T,T, x,T,T,x, T,x,x,T, T,x,T,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, T,T,T,T, x,T,T,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete dummyToken;
}

void Parser::SynErr(int n) {
    if (errDist >= minErrDist) {
        wchar_t* s;
        switch (n) {
    			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"ident expected"); break;
			case 2: s = coco_string_create(L"string expected"); break;
			case 3: s = coco_string_create(L"character expected"); break;
			case 4: s = coco_string_create(L"intcon expected"); break;
			case 5: s = coco_string_create(L"realcon expected"); break;
			case 6: s = coco_string_create(L"bincon expected"); break;
			case 7: s = coco_string_create(L"octcon expected"); break;
			case 8: s = coco_string_create(L"hexcon expected"); break;
			case 9: s = coco_string_create(L"semicol expected"); break;
			case 10: s = coco_string_create(L"colon expected"); break;
			case 11: s = coco_string_create(L"dotdot expected"); break;
			case 12: s = coco_string_create(L"dot expected"); break;
			case 13: s = coco_string_create(L"ABSTRACT expected"); break;
			case 14: s = coco_string_create(L"AND expected"); break;
			case 15: s = coco_string_create(L"ARRAY expected"); break;
			case 16: s = coco_string_create(L"BEGIN expected"); break;
			case 17: s = coco_string_create(L"BREAK expected"); break;
			case 18: s = coco_string_create(L"CASE expected"); break;
			case 19: s = coco_string_create(L"CLASS expected"); break;
			case 20: s = coco_string_create(L"CONST expected"); break;
			case 21: s = coco_string_create(L"CONSTANT expected"); break;
			case 22: s = coco_string_create(L"CONSTRUCTOR expected"); break;
			case 23: s = coco_string_create(L"CONTINUE expected"); break;
			case 24: s = coco_string_create(L"DEC expected"); break;
			case 25: s = coco_string_create(L"DESTRUCTOR expected"); break;
			case 26: s = coco_string_create(L"DIV expected"); break;
			case 27: s = coco_string_create(L"DO expected"); break;
			case 28: s = coco_string_create(L"DOWNTO expected"); break;
			case 29: s = coco_string_create(L"ELSE expected"); break;
			case 30: s = coco_string_create(L"END_ expected"); break;
			case 31: s = coco_string_create(L"EXCEPT expected"); break;
			case 32: s = coco_string_create(L"EXTERNAL expected"); break;
			case 33: s = coco_string_create(L"EXIT expected"); break;
			case 34: s = coco_string_create(L"FALSE expected"); break;
			case 35: s = coco_string_create(L"FAR expected"); break;
			case 36: s = coco_string_create(L"FILE expected"); break;
			case 37: s = coco_string_create(L"FINALIZATION expected"); break;
			case 38: s = coco_string_create(L"FINALLY expected"); break;
			case 39: s = coco_string_create(L"FOR expected"); break;
			case 40: s = coco_string_create(L"FORWARD expected"); break;
			case 41: s = coco_string_create(L"FUNCTION expected"); break;
			case 42: s = coco_string_create(L"GOTO expected"); break;
			case 43: s = coco_string_create(L"IDENT expected"); break;
			case 44: s = coco_string_create(L"IF_ expected"); break;
			case 45: s = coco_string_create(L"INC expected"); break;
			case 46: s = coco_string_create(L"INHERITED expected"); break;
			case 47: s = coco_string_create(L"HALT expected"); break;
			case 48: s = coco_string_create(L"HIGH expected"); break;
			case 49: s = coco_string_create(L"IMPLEMENTATION expected"); break;
			case 50: s = coco_string_create(L"INTERFACE expected"); break;
			case 51: s = coco_string_create(L"INITIALIZATION expected"); break;
			case 52: s = coco_string_create(L"IN expected"); break;
			case 53: s = coco_string_create(L"LABEL expected"); break;
			case 54: s = coco_string_create(L"LOOPHOLE expected"); break;
			case 55: s = coco_string_create(L"LOW expected"); break;
			case 56: s = coco_string_create(L"MOD expected"); break;
			case 57: s = coco_string_create(L"NOT expected"); break;
			case 58: s = coco_string_create(L"OBJECT expected"); break;
			case 59: s = coco_string_create(L"OF expected"); break;
			case 60: s = coco_string_create(L"ON expected"); break;
			case 61: s = coco_string_create(L"OR expected"); break;
			case 62: s = coco_string_create(L"ORIGIN expected"); break;
			case 63: s = coco_string_create(L"OTHERWISE expected"); break;
			case 64: s = coco_string_create(L"OVERLOAD expected"); break;
			case 65: s = coco_string_create(L"OVERRIDE expected"); break;
			case 66: s = coco_string_create(L"PACKED expected"); break;
			case 67: s = coco_string_create(L"PRIVATE expected"); break;
			case 68: s = coco_string_create(L"PROCEDURE expected"); break;
			case 69: s = coco_string_create(L"PROGRAM expected"); break;
			case 70: s = coco_string_create(L"PROTECTED expected"); break;
			case 71: s = coco_string_create(L"PUBLIC expected"); break;
			case 72: s = coco_string_create(L"RAISE_ expected"); break;
			case 73: s = coco_string_create(L"RECORD expected"); break;
			case 74: s = coco_string_create(L"REPEAT expected"); break;
			case 75: s = coco_string_create(L"RETURN expected"); break;
			case 76: s = coco_string_create(L"SET expected"); break;
			case 77: s = coco_string_create(L"SHL expected"); break;
			case 78: s = coco_string_create(L"SHR expected"); break;
			case 79: s = coco_string_create(L"STATIC expected"); break;
			case 80: s = coco_string_create(L"STR expected"); break;
			case 81: s = coco_string_create(L"THEN expected"); break;
			case 82: s = coco_string_create(L"TO_ expected"); break;
			case 83: s = coco_string_create(L"TRUE expected"); break;
			case 84: s = coco_string_create(L"TRY expected"); break;
			case 85: s = coco_string_create(L"TYPE expected"); break;
			case 86: s = coco_string_create(L"UNTIL expected"); break;
			case 87: s = coco_string_create(L"UNIT expected"); break;
			case 88: s = coco_string_create(L"USES expected"); break;
			case 89: s = coco_string_create(L"VAR expected"); break;
			case 90: s = coco_string_create(L"VIRTUAL expected"); break;
			case 91: s = coco_string_create(L"WHILE expected"); break;
			case 92: s = coco_string_create(L"WITH expected"); break;
			case 93: s = coco_string_create(L"XOR expected"); break;
			case 94: s = coco_string_create(L"READ expected"); break;
			case 95: s = coco_string_create(L"READLN expected"); break;
			case 96: s = coco_string_create(L"WRITE expected"); break;
			case 97: s = coco_string_create(L"WRITELN expected"); break;
			case 98: s = coco_string_create(L"PLUS expected"); break;
			case 99: s = coco_string_create(L"MINUS expected"); break;
			case 100: s = coco_string_create(L"MUL expected"); break;
			case 101: s = coco_string_create(L"DIVR expected"); break;
			case 102: s = coco_string_create(L"LET expected"); break;
			case 103: s = coco_string_create(L"LETADD expected"); break;
			case 104: s = coco_string_create(L"LETSUB expected"); break;
			case 105: s = coco_string_create(L"LETDIV expected"); break;
			case 106: s = coco_string_create(L"LETMUL expected"); break;
			case 107: s = coco_string_create(L"LETSHL expected"); break;
			case 108: s = coco_string_create(L"LETSHR expected"); break;
			case 109: s = coco_string_create(L"LETAND expected"); break;
			case 110: s = coco_string_create(L"LETOR expected"); break;
			case 111: s = coco_string_create(L"GT expected"); break;
			case 112: s = coco_string_create(L"LT expected"); break;
			case 113: s = coco_string_create(L"GE expected"); break;
			case 114: s = coco_string_create(L"LE expected"); break;
			case 115: s = coco_string_create(L"EQ expected"); break;
			case 116: s = coco_string_create(L"NE expected"); break;
			case 117: s = coco_string_create(L"C_NOT expected"); break;
			case 118: s = coco_string_create(L"C_OR expected"); break;
			case 119: s = coco_string_create(L"C_AND expected"); break;
			case 120: s = coco_string_create(L"C_ORBIN expected"); break;
			case 121: s = coco_string_create(L"C_ANDBIN expected"); break;
			case 122: s = coco_string_create(L"C_SHL expected"); break;
			case 123: s = coco_string_create(L"C_SHR expected"); break;
			case 124: s = coco_string_create(L"C_MOD expected"); break;
			case 125: s = coco_string_create(L"C_EQ expected"); break;
			case 126: s = coco_string_create(L"C_NEQ expected"); break;
			case 127: s = coco_string_create(L"CIRCUM expected"); break;
			case 128: s = coco_string_create(L"FUNCTION_BLOCK expected"); break;
			case 129: s = coco_string_create(L"END_FUNCTION_BLOCK expected"); break;
			case 130: s = coco_string_create(L"VAR_INPUT expected"); break;
			case 131: s = coco_string_create(L"VAR_OUTPUT expected"); break;
			case 132: s = coco_string_create(L"VAR_IN_OUT expected"); break;
			case 133: s = coco_string_create(L"VAR_EXTERNAL expected"); break;
			case 134: s = coco_string_create(L"VAR_CONST expected"); break;
			case 135: s = coco_string_create(L"END_VAR expected"); break;
			case 136: s = coco_string_create(L"END_FUNCTION expected"); break;
			case 137: s = coco_string_create(L"END_IF expected"); break;
			case 138: s = coco_string_create(L"END_FOR expected"); break;
			case 139: s = coco_string_create(L"END_WHILE expected"); break;
			case 140: s = coco_string_create(L"END_REPEAT expected"); break;
			case 141: s = coco_string_create(L"END_CASE expected"); break;
			case 142: s = coco_string_create(L"END_PROGRAM expected"); break;
			case 143: s = coco_string_create(L"END_TYPE expected"); break;
			case 144: s = coco_string_create(L"END_RECORD expected"); break;
			case 145: s = coco_string_create(L"END_CLASS expected"); break;
			case 146: s = coco_string_create(L"RETAIN expected"); break;
			case 147: s = coco_string_create(L"M_ADD expected"); break;
			case 148: s = coco_string_create(L"M_CONCAT expected"); break;
			case 149: s = coco_string_create(L"M_EQ expected"); break;
			case 150: s = coco_string_create(L"M_NE expected"); break;
			case 151: s = coco_string_create(L"M_GE expected"); break;
			case 152: s = coco_string_create(L"M_GT expected"); break;
			case 153: s = coco_string_create(L"M_LE expected"); break;
			case 154: s = coco_string_create(L"M_LT expected"); break;
			case 155: s = coco_string_create(L"M_MAX expected"); break;
			case 156: s = coco_string_create(L"M_MIN expected"); break;
			case 157: s = coco_string_create(L"M_MUL expected"); break;
			case 158: s = coco_string_create(L"M_MUX expected"); break;
			case 159: s = coco_string_create(L"OPENPAR expected"); break;
			case 160: s = coco_string_create(L"CLOSEPAR expected"); break;
			case 161: s = coco_string_create(L"OPEN_ANNO expected"); break;
			case 162: s = coco_string_create(L"CLOSE_ANNO expected"); break;
			case 163: s = coco_string_create(L"OPEN_BRACE expected"); break;
			case 164: s = coco_string_create(L"CLOSE_BRACE expected"); break;
			case 165: s = coco_string_create(L"\"[\" expected"); break;
			case 166: s = coco_string_create(L"\"]\" expected"); break;
			case 167: s = coco_string_create(L"\"~\" expected"); break;
			case 168: s = coco_string_create(L"\"@\" expected"); break;
			case 169: s = coco_string_create(L"\",\" expected"); break;
			case 170: s = coco_string_create(L"??? expected"); break;
			case 171: s = coco_string_create(L"invalid IdentRW"); break;
			case 172: s = coco_string_create(L"invalid Ident"); break;
			case 173: s = coco_string_create(L"invalid Constant"); break;
			case 174: s = coco_string_create(L"invalid CString"); break;
			case 175: s = coco_string_create(L"invalid ExprList"); break;
			case 176: s = coco_string_create(L"invalid ExprList"); break;
			case 177: s = coco_string_create(L"invalid RelOp"); break;
			case 178: s = coco_string_create(L"invalid AddOp"); break;
			case 179: s = coco_string_create(L"invalid MulOp"); break;
			case 180: s = coco_string_create(L"invalid SimpleExpr"); break;
			case 181: s = coco_string_create(L"invalid BinaryOp"); break;
			case 182: s = coco_string_create(L"invalid PrimaryExpr"); break;
			case 183: s = coco_string_create(L"invalid Internalexpr"); break;
			case 184: s = coco_string_create(L"invalid Primary_accessor"); break;
			case 185: s = coco_string_create(L"invalid Switchst"); break;
			case 186: s = coco_string_create(L"invalid Ifst"); break;
			case 187: s = coco_string_create(L"invalid Forst"); break;
			case 188: s = coco_string_create(L"invalid Forst"); break;
			case 189: s = coco_string_create(L"invalid Whilest"); break;
			case 190: s = coco_string_create(L"invalid Readst"); break;
			case 191: s = coco_string_create(L"invalid Writest"); break;
			case 192: s = coco_string_create(L"invalid Internalfst"); break;
			case 193: s = coco_string_create(L"invalid Type"); break;
			case 194: s = coco_string_create(L"invalid Function_type"); break;
			case 195: s = coco_string_create(L"invalid Decl_part"); break;
			case 196: s = coco_string_create(L"invalid Decl_part_common"); break;
			case 197: s = coco_string_create(L"invalid Proc_def"); break;
			case 198: s = coco_string_create(L"invalid Decl_part_forward"); break;
			case 199: s = coco_string_create(L"invalid Proc_decl"); break;
			case 200: s = coco_string_create(L"invalid Formal_params"); break;
			case 201: s = coco_string_create(L"invalid Formal_param"); break;
			case 202: s = coco_string_create(L"invalid Pascal"); break;
			case 203: s = coco_string_create(L"invalid StVarDecl"); break;
			case 204: s = coco_string_create(L"invalid StParamDecl"); break;
			case 205: s = coco_string_create(L"invalid StType"); break;
			case 206: s = coco_string_create(L"invalid StProc_def"); break;
			case 207: s = coco_string_create(L"invalid StDecl_part"); break;

            default:
            {
                wchar_t format[20];
                coco_swprintf(format, 20, L"error %d", n);
                s = coco_string_create(format);
            }
            break;
        }
        errors->Error(la->line, la->col, s);
        coco_string_delete(s);
    }
    errDist = 0;
}

} // namespace

