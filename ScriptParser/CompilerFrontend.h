/*
 * Copyright (C) 2017 Smirnov Vladimir mapron1@gmail.com
 * Source code licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 or in file COPYING-APACHE-2.0.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.h
 */
#pragma once
#include <QByteArray>
#include <QFile>
#include <QStringList>
#include <QVariant>
#include <QMap>
#include <QPair>

#include <functional>
#include <vector>

namespace PascalLike {
class Parser;
class Scanner;
}
namespace AST {
struct CodeMessage;
class CodeMessages;
struct TToken;
}
class TreeVariant;
class CodeGenerator;
class ScriptVM;
struct CompilerFrontendPrivate;
class ScriptVariant;
class SymTable;
class BlockScope;

/// Pascal parser and code generator wrapper.
class CompilerFrontend
{
public:
	enum Semantic { smPascal, smAssignment };

	// Execution debug flags:s

	//            | PascalLikeWrapper::dOpcode      // outout current opcode
	//            | PascalLikeWrapper::dStack       // output stack each step
	//            | PascalLikeWrapper::dExternalVars// dump external vars
	//            | PascalLikeWrapper::dStaticVars  // dump static vars
	//            | PascalLikeWrapper::dCallStack   // output call stack each step
	//            | PascalLikeWrapper::dOperations  // output binary and unary operations

	//            | PascalLikeWrapper::dAstDump         // dump AST of parser.
	//            | PascalLikeWrapper::dNameTable       // dump name table of parser.
	//            | PascalLikeWrapper::dBytecode        // ouput generated bytecode.
	//            | PascalLikeWrapper::dCompileMessages // output compiler messages (warnings)

	//            | PascalLikeWrapper::dEmergencyMode   // redirects output to std::cout, disable buffering (helps debugging VM crashes).


	enum DebugFlags {dNone = 0,
					 // runtime flags:
					 dOpcode = 1 << 1, dStack = 1 << 2, dExternalVars = 1 << 3, dStaticVars = 1 << 4, dCallStack = 1 << 5, dOperations = 1 << 6,  dEmergencyMode = 1 << 7,
					 // complietime flags:
					 dAstDump = 1 << 16,dNameTable = 1 << 17, dBytecode = 1 << 19,dCompileMessages = 1 << 20,

					 dAllRuntime = dOpcode | dStack | dExternalVars | dStaticVars | dCallStack | dOperations,
					 dAllCompile = dNameTable | dBytecode | dCompileMessages | dAstDump,
					 dAll = dAllRuntime | dAllCompile | dEmergencyMode
					};

	enum OutChannel { ocError, ocStd, ocDebug };

	enum ParserOptions {poNone = 0, poForbidExternal = 1 << 0 };

	using funCallbackWrapper = std::function< void(std::vector<ScriptVariant*>  &, std::vector<ScriptVariant*>  & )>;


	CompilerFrontend();
	~CompilerFrontend();
	bool parseText(const QString &text, bool emptyTextIsValid = true);

	bool parseDataObjectsList(const TreeVariant &data);
	bool pascal2c(const QString &pascalText, QString & ctext);
	bool run(bool firstRun = true);
	bool isFinished();
	SymTable* getSymTable();

	void clearBindings();
	void addFuncs(QStringList protos, QString classname = "");
	void addFuncs(const std::vector<std::string> & protos);
	void addVars(const QList<QPair<QString, QString> >& vars);
	void addVars(const TreeVariant& vars);
	void addClass(QString name, const TreeVariant& fields, const QStringList &methods = QStringList());
	void addClasses(const TreeVariant& classesMap);
	void setLibraries(const TreeVariant &libraries);

	void bindFuncs(QMap<QString, funCallbackWrapper> funcs);
	void bindFunc(QString id,  funCallbackWrapper func);

	QStringList getInternalTypes();
	TreeVariant getExternalBindings() const;
	TreeVariant getDeclaredTypes() const;
	TreeVariant getLibraries() const;

	void saveToFile(QString filename);
	QByteArray exportData();

	ScriptVM* vm();

	Semantic semantic() const;
	void setSemantic(Semantic s);

	void setParserFlag(int flag, bool value);

	DebugFlags debugFlags() const;
	void setDebugFlags(int flags);
	void setDebugFlag(int flags, bool value);

	void setExecuteLimit(int limit);

	QByteArray getOutput(OutChannel channel = ocStd) const;
	inline QByteArray getOutputError() const { return getOutput(ocError); }

	TreeVariant functionsDescr() const;
	TreeVariant classesDescr() const;
	TreeVariant variables() const;
	const AST::CodeMessages &messages() const;

	void makeTokenList(const QString& text,  QList<AST::TToken> &list);

private:
	void registerSymTable();
	QString preprocess(const QString &data);
	bool prepareVM(bool firstRun,
				   std::ostringstream &virtDebug,
				   std::ostringstream &virtStd,
				   std::ostringstream &virtErr);

private:
	 CompilerFrontendPrivate* d;
};
